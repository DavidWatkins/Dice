include("stdlib");

(**
 * Implementation of Location that has horizontal and verticale coordinates
 * 
 * @author David Watkins
 * @UNI djw2146
 *)
class LocationObj {
 (* ================================== *)

    private int horizontal;
    private int vertical;
    
    (**
     * Creates a LocationObj with horizontal and vertical coordinates
     * 
     * @param horizontal x coordinate
     * @param vertical y coordinate
     *)
    constructor(int horizontal, int vertical){
        this.horizontal = horizontal;
        this.vertical = vertical;
    }
    
    (* 
     * @Return Horizontal coordinate
     *)
    (* @Override *) (* ================================== *)
    public int getHorizontal() {
        return this.horizontal;
    }
    
    (* 
     * @Return Vertical coordinate
     *)
    (* @Override *) (* ================================== *)
    public int getVertical() {
        return this.vertical;
    }
}
(**
 * Maintains and operates on the board.
 * Has methods for checking if particular moves are valid and initializing the board.
 * 
 * @author David Watkins
 * UNI djw2146
 *)
class Board {
    private int[] board;
    
    (**
     * Initializes a new board with size Game.SIZE x Game.SIZE
     *)

    constructor(){
        this.board = new int[64];
        this.initializeBoard();
    }
    
    (**
     * Initializes the board to have the center most four pieces in the correct formation
     * 
     * @param type The type of player, as the user of the Board could differ
     *)
    public void initializeBoard(){
        int i;
        int j; (* =========================== *)
        int[] board = this.board;
        for (i = 0 ; i < 8 ; i = i + 1) {
            for (j = 0 ; j < 8 ; j = j + 1) {
                board[i+j]=2;
            }
        }

        board[(3*8)+4] = 1;
        board[(4*8)+3] = 1;
        board[(3*8)+3] = 0;
        board[(4*8)+4] = 0;
    }

    (**
     * Prints out a formatted version of the board to the console.
     *)
    public void printBoard() {
        print("-----------------------------------------------------------------");
        int i;
        int j;
        int[] board = this.board;

        for(i = 0; i < 7; i=i+1){  (* =========================== *)
        (* Prints out each line individually *)
            for( j = 0; j < 7; j = j + 1){
            (* =========================== *)
            (*//Prints out each section of a line of the board*)
                if(board[(j*8+i)] == 0) {  (*//SELF player*)
                    print("|(WHITE)");
              }  else if(board[(8*j)+i] == 1) { (*//OPPONENT player*)
                    print("|(BLACK)");
              }  else { (*//No piece in location*)
                    print("|(", (j+1), ",  ", (i+1), ")");
              }
            }
            print("|"); (*//Finishes the line*)
            print("\n");
        }
        print("-----------------------------------------------------------------");
        print("\n");
    }

    (**
     * Checks all possible indices of the board to determine whether or not a winner has been determined
     * Counts the number of each piece and returns the type of winner
     * 
     * @return The winner if there is a winner, null if no winner is determined yet
     *)
    public int thereIsWinner(){
        int[] temp = this.totalCount();
        
        if(temp[0] + temp[1] == 64){ (*//If the total number of pieces equals the entire board *)
            return this.whoHasMore();
        } else { (*//If no winner yet *)
            return -1;
        }
        return 9;
    }
    
    (**
     * A method for determining which player has more pieces on the board. 
     * 
     * @return Which PIece has more positins in the board
     *)
    public int whoHasMore(){
        int[] temp = this.totalCount();
        
        if(temp[0] > temp[1]) {
            return  0;
      }  else if(temp[1] > temp[0]) {
            return 1;
      }  else { (* //If there is a tie *)
            return 2;
      }
        (* default return *)
        return 9;
    }
    
    (**
     * Private helper metod for determining the current count of a particular type of player
     * 
     * @return A size two vector containing whiteCount is [0] and blackCount in [1]
     *)
    private int[] totalCount(){
        int whiteCount = 0;
        int blackCount = 0;
        int i;
        int j;
        int[] board = this.board;
        for(i = 0; i < 8; i = i + 1) {  (* =========================== *)
            for(j = 0; j < 8; j = j + 1) { (* =========================== *)
                if(board[(i*8)+j] == 0) {
                    whiteCount = whiteCount + 1;
               } else if(board[(i*8)+j] == 1) {
                    blackCount = blackCount + 1;
               }
            }
        }
        int[] temp = new int[2];
        temp[0] = blackCount;
        temp[1] = whiteCount;
        return temp;
    }
    
    (**
     * Will check to see if the particular direction is a valid move
     * If bool updateBoard is true, will also update any pieces appropriately modified by a particular player move.
     * Is only privately used by isValid and setPlayerMove to make sure a move is valid
     * Returns 0 if the direction is invalid
     * 
     * @param move The player's new move
     * @param incx The coefficient of x
     * @param incy The coefficient of y
     * @param player The current player playing the new move
     * @param updateBoard Whether or not to update pieces
     * @return Whether the move is valid or not
     *)


    private bool checkDir(class LocationObj move, int incx, int incy, int player , bool updateBoard)  {

        int[] board = this.board;
        int opponent; (*//The opposite color of player*)
        int x = move.getHorizontal();
        int y = move.getVertical();
        
        (*//Current player's move *)
        if (player == 1) { (* =========================== *)
            opponent=0; 
       } else {
            opponent=1;
        }
        (* /Modify the position by one *)
        int dist = 0;
        x = x + incx; 
        y = y + incy;
        
        (*//While x and y are in bounds and the current position is an opponent piece *)
        while ((x < 8) and (x >= 0) and (y < 8) and (y >= 0) and (board[(x*8)+y] == opponent)) { (* =========================== *)
            x = x + incx; 
            y = y + incy; 
            dist = dist + 1;
        }

        (* //If x and y are still in bounds and the final position is a player piece, will *)
        if ((dist != 0) and (x < 8) and (x >= 0) and (y < 8) and (y >= 0) and (board[(x*8)+y]==player)) { (* =========================== *)
             if (updateBoard) { (* //Will update the board if true *)
                 int j;
                 for (j = 1 ; j <= dist ; j = j+1) {
                    x = x - incx; (*//Decrease x by one*)
                    y = y - incy; (*//Decrease y by one*)
                    class LocationObj l = new LocationObj(x,y);
                    this.setLoc(l,player); (*//Update location to player piece *)
                 }
            return true; (* //The current distance from the initial position *)
            } else {
                return false; (*//Not a valid direction *)
        }
    }
    (* default return *)
    return false;
}
    (**
     * Will set the location defined by move to the type player
     * 
     * @param move The position to be modified
     * @param player The player's type
     *)
    private void setLoc(class LocationObj move, int player){
        (* =========================== *)
        int[] board = this.board;
        board[(move.getHorizontal()*8)+move.getVertical()] = player;
    }
    
    (**
     * Sets the location of a particular player (c)'s move. Returns false
     * if move is invalid.
     * 
     * @param move Location object containing horizontal and vertical
     * coordinates
     * @param c The type of player currently placing tile
     * @return False if invalid move
     *)


    public bool setPlayerMove(class LocationObj move, int player) {
        bool valid = false;
        int yinc = 0;
        int xinc = 0;
        int[] board = this.board;
 
        (* //If move is null or move space is taken up *)
        if(move == null or board[(move.getHorizontal()*8)+move.getVertical()] != 2) { (* =========================== *)
            return false;
        }
        int i;
        for(i = 0; i < 8; i = i + 1){ (*//For the length of potential neighbors*)
            (*//Linear Directions *)
           if(i == 0){xinc = 1; yinc = 0;} (*//E *)
           else if(i == 1){xinc = -1; yinc = 0;} (* //W *)
           else if(i == 2){xinc = 0; yinc = 1;} (* //S *)
           else if(i == 3){xinc = 0; yinc = -1;} (* //N *)
           
           (*//Diagonals*)
           else if(i == 4){xinc = 1; yinc = 1;}(*//SE*)
           else if(i == 5){xinc = -1; yinc = 1;}(*//SW*)
           else if(i == 6){xinc = 1; yinc = -1;}(*//NE*)
           else if(i == 7){xinc = -1; yinc = -1;}(*//NW*)
           
           (*//Change all potential old markers*)
           if(this.checkDir(move, xinc, yinc, player, true)) {
               valid = true;
            }
        }
        
        if (valid) { (*//Valid move*)
            setLoc(move, player);
            return true;
        }
        return false; (*//Invalid move*)
    }
    
    (**
     * Checks all possible directions to determine whether or not a move is valid
     * Uses the private method checkDir to make sure that the move is valid
     * 
     * @param move The current move to be checked
     * @param kind The current type of player's move
     * @return Whether or not the move was valid
     *)
    public bool isValid(class LocationObj move, int kind) {
        int yinc = 0;
        int xinc = 0;
        int[] board = this.board;
        (*//If move is null, within the boundaries of the array, or move space is taken up *)
        if(move == null or 
                ((move.getHorizontal() > 0 and move.getHorizontal()< 8
                and move.getVertical() > 0 and move.getVertical() < 8) == false) or
                (* =========================== *)
                this.board[(move.getHorizontal()*8)+move.getVertical()] != 2) {
            return false;
        }
        int i;
        for(i = 0; i < 8; i = i +1){ (*//For the length of potential neighbors*)
            (*//Linear Directions*)
           if(i == 0){xinc = 1; yinc = 0;}(*//E*)
           else if(i == 1){xinc = -1; yinc = 0;}(*//W*)
           else if(i == 2){xinc = 0; yinc = 1;}(*//S*)
           else if(i == 3){xinc = 0; yinc = -1;}(*//N*)
           
           (*//Diagonals*)
           else if(i == 4){xinc = 1; yinc = 1;}(*//SE*)
           else if(i == 5){xinc = -1; yinc = 1;}(*//SW*)
           else if(i == 6){xinc = 1; yinc = -1;}(*//NE*)
           else if(i == 7){xinc = -1; yinc = -1;}(*//NW*)

           (*//Move is valid*)
           if (this.checkDir(move, xinc, yinc, kind, false)) { 
               return true;
            }
        }
        (*//Move was invalid for all directions*)
        return false;
    }
    
    (**
     * Determines whether or not there is a valid move available for a particular player
     * 
     * @param player The current player's color
     * @return Whether or not the particular player can play
     *)
    public bool userMoveAvailable(int player)  {
        int i;
        int j;
        int[] board = this.board;
        for (i = 0 ; i < 8 ; i=i+1) {
            for (j = 0 ; j < 8 ; j=j+1) {
                (*//If the potential position is not occupied and is a valid move*)
                class LocationObj l = new LocationObj(j,i);
                if ((board[(j*8)+i] == 2) and this.isValid(l,player)) { (* =========================== *)
                    return true;
                }
            }
        }
        return false;
    }

}
