\begin{homeworkProblem}
	\section{Expressions and Operators}
    The precedence of expression operators is the same as the order of the major subsections of this section (highest precedence first). Within each subsection, the operators have the same precedence. Left- or right-associativity is specified in each subsection for the operators discussed therein.
	\subsection{Primary Expressions}
	Primary expressions involving . , subscripting, and function calls group left to right.
	
	\subsubsection{Identifier}
    An identifier is a primary expression, provided it has been suitably declared as discussed below. Its type is specified by its declaration.
    
	\subsubsection{Literal}
    Any of the literal types discussed in Chapter 3 is a primary expression, which evaluates to the type of the literal.

    \subsubsection{( expression )}
    A parenthesized expression is a primary expression whose type and value are identical to those of the unadorned expression. The presence of parentheses does not affect whether the expression is an lvalue.

    \subsubsection{primary-expression [ expression ]}
    A primary expression followed by an expression in square brackets is a primary expression. The intuitive meaning is that of a subscript. The primary expression has type ‘‘$array$ of . . .’’ and the type of the result is ‘‘. . . ’’. The type of the subscript expression must be a type that is convertible to an integral type, or a compile-time error occurs.

    \subsubsection{primary-expression ( expression-list-opt )}
    A function call is a primary expression followed by parentheses containing a possibly empty, comma-separated
    list of expressions which constitute the actual arguments to the function. The result of the function call is the function's return type. Recursive calls to any function are permissible.

    \subsubsection{primary-lvalue . member-of-structure}
	An lvalue expression followed by a dot followed by the name of a class member is a primary expression. The object referred to by the lvalue is assumed to be an instance of the class defining the class member. The given lvalue can be an instance of any user-defined class.

    \subsection{Unary operators}
    Expressions with unary operators group right-to-left.

    \subsubsection{− expression}
    The result is the negative of the expression, and has the same type. The type of the expression must be $char$, $int$, or $float$.

    \subsubsection{not expression}
    The result of the logical negation operator $not$ is $true$ if the value of the expression is $false$, $false$ if the value of the expression is $true$. The type of the result is $bool$. This operator is applicable only to operands that evaluate to $bool$.

    \subsection{Multiplicative operators}
    The multiplicative operators * and / group left-to-right.

    \subsubsection{expression * expression}
    The binary * operator indicates multiplication. Operands of $int$, $float$, and $char$ types are allowed. If both operands are of type ..., the result is type .... If the operands are of two different types of the ones listed above, the result is the type of the left-most operand.

    \subsubsection{expression / expression}
    The binary / operator indicates division. The same type considerations as for multiplication apply.

    \subsection{Additive operators}
    The additive operators + and − group left-to-right.

    \subsubsection{expression + expression}
    The value of the result is the sum of the expressions. The same type considerations as for multiplication apply. Overflow of a $char$ type during an addition operation results in wraparound.

    \subsubsection{expression - expression}
    The value of the result is the difference of the expressions. The same type considerations as for multiplication apply.

    \subsection{Relational operators}
    The relational operators group left-to-right.
    
    \subsubsection{expression $<$ expression}
    \subsubsection{expression $>$ expression}
    \subsubsection{expression $<=$ expression}
    \subsubsection{expression $>=$ expression}
    The operators $<$ (less than), $>$ (greater than), $<=$ (less than or equal to) and $>=$ (greater than or equal to) all yield $true$ is the specified relation is true and $false$ otherwise. The same type considerations as for multiplication apply.

    \subsection{Equality operators}

    \subsubsection{expression == expression}
    \subsubsection{expression != expression}
    The == (equal to) and the != (not equal to) operators are exactly analogous to the relational operators except for their lower precedence.

    \subsection{Logical operators}

    \subsubsection{expression and expression}
    Both operands must evaluate to a value of type $bool$. The $and$ operator returns $true$ if both its operands evaluate to $true$, $false$ otherwise. The second expression is not evaluated if the first evaluates to $false$.

    \subsubsection{expression or expression}
    Both operands must evaluate to a value of type $bool$. The $or$ operator returns $true$ if either of its operands evaluate to $true$, and $false$ otherwise. The second operand is not evaluated if the value of the first operand evaluates to $true$.

    \subsection{Assignment operators}

    \subsubsection{lvalue = expression}
    The value of the expression replaces that of the object referred to by the lvalue. Both operands must have the same type.
    \end{homeworkProblem}
