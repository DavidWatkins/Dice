\begin{homeworkProblem}
	\chapter{Architecture}
	\section{The Compiler}
	\subsection{The Lexer}
    The lexer scans through the input file and tokenizes the input, discarding characters which are no longer need such as whitespace.
	
	\subsection{The Parser}
    The parser scans the tokens passed to it by the scanner and constructs an abstract syntax tree based on the definitions provided and the input tokens. The top level of the abstract syntax tree is a structure containing all classes and a structure containing all include statements. 
	\subsection{The Semantic Analyzer}
    The first job of the Analyzer is to run the Lexer and Parser on any files containted in the includes structure of the given abstract syntax tree. The process of building an abstract syntax tree is the same for these files as for the originally compiled file. If any of these new abstract syntax trees contain include statements, the same process is run until there are no more includes. Similarly, each time a new included file's abstract syntax tree is passed to the Analyzer, all classes contained in the class structure of the new abstract syntax tree are appended to the original class list contained in the original class structure which was in the original abstract syntax tree. Once this process is complete, the analyzer is left with a class structure which contains every class defined in every file which was included with the originally compiled file.
    Next, the Analyzer performs an inheritance analysis by looking through the class list contained in the class structure and performs an analysis to determine whether any class' are children or parents of other classes. If there are any such relationships, the fields of each parent class are added to the front of its child's fields list, and the methods of each parent class are added to the child's method's list. However, if the child has declared a method or field which shares the same name as the parent's field or method, the child's field or method is not overwritten by the parent. As the inheritance analysis is performed, the list of fields for each class is also assigned a integer key beginning with 0 which will serve as the key to a lookup table which, at runtime, contains pointers to every function for each class.
    Once the inheritance analysis is performed, semantic analysis is performed on each statement and expression in each block of code in every method for every class. This semantic analysis consists of making sure that types are consistent in every expression, making sure variables are declared and in the proper scope, and making sure that variables are only declared once. For instance, if an integer x is declared and x is assigned to the return of a method, the analyzer checks that the called method returns the type of x, namely an integer.
    As this analysis is performed, the analyzer is simultaniously constructing a semantic abstract syntax tree. The purpose of this new data structure is to provide the code generator with data that is organized more similarly to the LLVM code that it will eventually produce. Thus, instead of classes containing methods and fields, the top level program structure now contains separate sections for methods and fields. This is useful for the code generator because the LLVM code that is produced uses structs to store the fields of a class and functions to store the code within a class's methods. Thus, there is no inherent connection between the functions and the structs in llvm. However, the analyzer modifies each method so that an instance of the structure containing the fields of the given class is passed in as the first argument to every funtion for that class. In this way, functions can access each field of a given class by accessing the data inside of the structure. 

	\subsection{The Code Generator}
	\subsection{The Utilities}
	Pretty printing, token printing, JSON printing
	\section{Supplementary Code}
	\subsection{The Standard Library}
	\subsection{Built-in Functions}
	\subsection{Functions Implemented in C}
\end{homeworkProblem}
